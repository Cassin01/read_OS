# 03 プロセスの制御
親プロセスは子プロセスを生成し、
子プロセスの実行結果を受け取る

# プロセスのコピー　
## ``proc[]``のコピー
このとき

子プロセスの親プロセスのIDを保管する``proc.p_ppid``は親プロセスの``proc.p_pid``をコピーする

## データセグメント、PPDAのコピー
* 子プロセスの``user.u_procpは``自身の``user``構造体に対応した子プロセスの``proc[]``エントリを持つ

* テキストセグメントは親プロセスの同じtext[]エントリを指すため
コピーされない

# お互いどのように参照するか
## 子プロセスが親プロセスを知る
``proc.p_ppid``に親プロセスのIDが設定されるのでそこを見れば良い
## 親プロセスが自分の子プロセスを知る
(子プロセスの)``proc[]``を全て調べ
自身の親プロセスのIDを示す``proc.p_ppid``が自身を指しているプロセスを見つける必要がある

# forkシステムコール
システムコールの処理はカーネルプロセスにより行われる

forkシステムコールからは、親プロセスと子プロセス用に2回返される　

```c
// fork() (sys/ken.c)
// 親プロセスの処理
fork() {
  register struct proc *p1, *p2;

  p1 = u.u_procp; // 実行プロセス(親プロセスのproc構造体をp1に格納)

  // proc[]の空きエントリを探す
  for(p2 = &proc[0]; p2 , &proc[NPROC]; p2++) {
    if (p2 -> p_start = NULL) {
      goto found;
    }
  }

  // EAGAIN: forkシステムコールで、proc[]に空きエントリが見つからなかった
  u.u_error = EAGAIN;

  goto out

found:
 // newproc(): 新しいプロセスを生成 (親プロセス: 0, 子プロセス: 1)
 if(newproc()) {
    // p_pid(親プロセスのID)をユーザプロセスのr0に格納
    // これが子プロセスへのforkシステムコールからの戻り値
    u.u_ar0[R0] = p1->p_pid;

    // プロセスの実行時間情報を0に初期化し直す
    u.u_cstime[0] = 0;
    u.u_cstime[1] = 0;
    u.u_stime = 0;
    u.u_cutime[0] = 0;
    u.u_cutime[1] = 0;
    u.u_utime = 0;
    return;
  }

  // 子プロセスのproc.p_pidを親プロセスのr0に格納
  // p_pid: プロセスのID
  // これがforkシステムコールの戻り値となる
  u.u_ar0[R0] = p2->p_pid;

out:
  // 親プロセスのプログラムカウンタを1命令分進める
  u.u_ar0[R7] =+ 2;
}
```

```assembly
/ Cライブラリのfork() (source/s4/fork.s)
/ PDPアセンブリではバックスラッシュはコメント

.globl  _fork, cerror, _par_uid

_fork:
  mov   r5,-(sp)
  mov   sp,r5
  sys   fork
    / brはジャンプ命令
    / 1fは前方の１ラベル(1:)にジャンプすることを表す
    br  1f
  bec   2f
  jmp   cerror

1:
  / 親プロセスのproc.p_pidを_par_uidにコピー
  / Cライブラリのfork()を実行したユーザプログラムはこの値を見ることで親プロセスのIDを取得できる
  mov   r0,_par_uid

  / r0をクリア
  clr   r0

2:
  mov   (sp)+,r5

  / rts命令でCライブラリのfork()呼び出し元へ戻りr0に格納された0が返る
  rts   pc

.bss
_par_uid: .=.+2
```

# newproc()